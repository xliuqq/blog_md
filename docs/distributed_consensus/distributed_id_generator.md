# 分布式ID生成算法

在应用程序中，经常需要全局唯一的ID作为数据库主键。分布式ID的核心需求：

- 全局唯一
- 趋势有序 | 单调递增
- id不能连续

## UUID

**优点**：

- 本地生成ID，不需要进行远程调用，时延低
- 扩展性好，基本可以认为没有性能上限

**缺点**：

- 无法保证趋势递增
- uuid过长，往往用字符串表示，作为**主键建立索引查询效率低**，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）

## 数据库自增ID

 **使用数据库的 auto_increment 来生成全局唯一递增ID** 

**优点：**

- 简单，无其它组件依赖
- 能够保证唯一性和递增性
- 步长固定

**缺点：**

- 扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展
- 主从切换时的不一致可能会导致重复发号 
-  数据在插入前，无法获得ID。数据在插入后，获取的ID虽然是唯一的，但一定要等到事务提交后，ID才算是有效的。有些双向引用的数据，不得不插入后再做一次更新，比较麻烦 

**改进方法：**

- 数据水平切分，保证各主库生成的ID不重复，但不容易扩展，需要提前规划

类似的还有redis的incr实现。


## SnowFlake算法

 采用 **41bit 毫秒时间戳**，加上**10bit 机器ID**，加上**12bit 序列号**，理论上**最多支持1024台机器每秒生成4096000个序列号**。workerID可以通过ZK管理。

**优点：**

1）毫秒数在高位，自增序列在低位，整个ID都是趋势递增的；

2）不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的；

3）可以根据自身业务特性分配bit位，非常灵活。

**缺点：**

强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。

## Leaf-Segment

**Leaf-segment对数据库自增ID方案做了如下改变：**

1）原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次**获取一个segment(step决定大小)号段**的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力；

2）各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。

3）双buffer缓存，第一个buffer消费到一定程度，异步线程获取另一个buffer的号段；

 **Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，但不适用于订单ID生成场景** 