# 数据库

## 数据库系统

从应用人员角度，分为<font color=red>**三级模式**</font>：

- **外模式**：外部视图，**用户看到或使用的哪部分数据的逻辑结构**，一个数据库多个外模式；
- **概念模式**：概念视图，**全体数据的逻辑结构**，**所有用户的公共视图**，**一个数据库只有一个概念模式**；
- **内模式**：内部视图，**索引和存储路径**，数据库内部如何存储数据；



数据库<font color=red>**两级独立性**</font>：

- **逻辑独立性**：**当模式改变时**（如新增列），对外模式/概念模式的映像做相应改变，保持**外模式不变**；
  - 保证数据与程序的逻辑独立性，简称数据的逻辑独立性；
- **物理独立性**：当数据的**存储结构**（如索引方式）改变（内模式改变），对概念模式/内模式映像做改变，保持**概念模式不变**；
  - 保证数据与程序的物理独立性，简称数据的物理独立性；

## 数据模型

**概念数据模型**（**ER模型**）：按照**用户的观点**对数据和信息建模，ER图；

**基本数据模型**：按照**计算机系统的观点**对数据和信息建模；

- **层次模型、网状模型、关系模型、面向对象模型**；



## 关系型数据库

### 键

**候选键**：不含有多余属性的朝见称为候选键；

**主键**：用户挑选的用作元组标志的一个候选键；

**主属性**：任一个候选键中的属性称为主属性；



### 关系代数

自然连接：会将**重复的属性列去掉**，而**等值连接不会（且=需要指定列）**；



### 函数依赖

$ X \rightarrow Y $：X 决定 Y，或者 Y 依赖 X；

**非平凡的函数依赖**：$X \rightarrow Y, 但 Y \subsetneq  X$，则 $X \rightarrow Y$ 是非平凡函数依赖；

**平凡的函数依赖**：$X \rightarrow Y, Y \subseteq X$，则$X \rightarrow Y$ 是平凡函数依赖；



**完全函数依赖**：

**部分函数依赖**：

**传递依赖**：



### **Armstrong** 公理

<font color=red>**Armstrong 公理**</font>：设关系式 R(U, F)，**U是关系模式R的属性集**，F是U上一组**函数依赖**，则有以下规则：

- **自反律**：若  $ {Y} \subseteq X \subseteq U $，则 $X \rightarrow Y$ 为 F 所蕴含；
- **增广律**：若 $ X \rightarrow Y$ 为 F 所蕴含，且 $Z \subseteq U$，则$XZ \rightarrow YZ$ 为 F 所蕴含；
- **传递律**：若 $ X \rightarrow Y, Y \rightarrow Z $ 为 F 所蕴含，则$ X \rightarrow Z $为 F 所蕴含；

以下是推导规则：

- 合并规则：若$ X \rightarrow Y, X \rightarrow Z $ 为 F 所蕴含，则$ X \rightarrow YZ $为 F 所蕴含；
- 伪传递规则：若$ X \rightarrow Y, WY \rightarrow Z $ 为 F 所蕴含，则$ XW \rightarrow Z $为 F 所蕴含；
- 分解规则：若$ X \rightarrow Y, Z \subseteq Y $ 为 F 所蕴含，则$ X \rightarrow Z $为 F 所蕴含；

### 范式

范式：符合某一种级别的关系模式的集合：

- **1NF**： 关系模式R的**每一个分量是不可再分的数据项**，则属于第一范式；
- 2NF：满足1NF，**且每一个非主属性完全依赖于主键时**，则属于第二范式；
  - 示例：不满足，（学号，学生名，课程号，课程描述），主键（学号、课程号），存在 学号 -> 学生名的非主属性部份依赖主键；
- **3NF**：满足2NF，且**无非主属性对主键的传递依赖**时，则属于第三范式；
- BCNF：当且仅当**F中每个依赖的决定因素必定包含R的某个候选键（即每个属性都不传递依赖主键）**；
- 4NF：基于BCNF，消除多值属性；



### 关系模式分解

#### 无损连接

R(U, F)，分解$\delta = \{ R_1, R_2, ...\}$ 是<font color=red>**无损连接**</font>，

- 只有两个分解时：充要条件是：$(R_1 \cap R_2) -> (R_1 - R_2)$ 或 $(R_1 \cap R_2) -> (R_2 - R_1)$  
  - 可以理解成：拆了一张独立的表出去；

- 多个分解时，**任意 Ri 根据 F 可以直接（不能传递推出）推出 U**，则是无损依赖；

#### 函数依赖保持

R(U, F)，分解$\delta = \{ R_1, R_2, ...\}$ ，$\delta$中每个模式Ri的函数依赖集是Fi，**如果${F_1, F_2, ...}$ 与 F 是等价的（相互蕴含，通过Armstrong 公里推导）**，则称分解<font color=red>**保持函数依赖**</font>。



## 数据库设计

<font color=red>**阶段**</font>：

- **规划阶段**：建立数据库的必要性、可行性；
- **需求分析**：收集需求，**需求规格说明书、数据字典**；
- **概念设计**：建立概念模型，E-R图；
  - <font color=red>**抽象数据 -> 设计局部视图 -> 合并取消冲突 -> 修改重构消除冗余**</font>

- **逻辑设计**：建立逻辑模型，**关系模式**；

- **物理设计**：建立物理模型，’**create table**'，依赖DBMS；



### 反规范化

- 增加冗余列：如成绩表除了学号，还有学生姓名；
- 增加派生列；减少计算量，加快速度，比如总数；
- 重新组表：如宽表；
- 分割表：水平分割、垂直分隔；



## 事务管理

### ACID

- 原子性：没有部分成功；
- 一致性：从一个一致性状态到另一个一致性状态；
- 隔离性：不能被其他事务干扰；
- 持久性：一旦提交，改变即永久；

### 并发控制



共享锁（S）：

排他锁（X）：



## 备份

**完全备份**：数据库的全部内容备份；

- 备份时间长；

**增量备份**：只备份**上次完全、增量、或差异备份**以来修改的数据；

- 保留所有的增量备份，依次恢复，时间较长；

**差异备份**：备份上次**完全备份后**发生变化的所有数据；



## 分布式数据库



## 数据仓库

数据仓库：**面向主题的、集成的、相对稳定的、反应历史变化**的数据集合，用于支持管理决策。

- 联机分析处理：OLAP

  

## 数据挖掘

关联分析、序列分析、分类、聚类等。

- 序列模式分析：侧重点是分析数据间的**前后因果关系**。

### CAP和BASE理论

