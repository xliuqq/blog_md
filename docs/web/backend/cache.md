# 缓存

## 思想

> 通过缓存将复杂的操作的结果临时存储，提升性能。

### 功能

- 支持并发操作，如采用数据结构`ConcurrentHashMap`；
- 支持 TTL，即支持过期时间；
  - 支持 每个记录的TTL，即不同的记录可以设置不同的过期时间；
- 支持定义缓存的大小（记录数/字节数），防止内存溢出；
- 支持自动的数据加载，即获取不到时的处理方法；

对于分布式场景，需要通过 Redis 集中系统实现分布式缓存。

**缓存清除策略**

- **LRU**：最近最久未使用

- **LFU**：最近少频率，对于热点数据命中率更高，但需要记录额外字段信息（访问次数）；



### 一致性问题

> 缓存最好设置 TTL，至少最终一致性。
>
> [缓存更新的套路 | 酷 壳 - CoolShell](https://coolshell.cn/articles/17416.html)
>
> 更新缓存的的Design Pattern有四种：**Cache aside, Read through, Write through, Write behind caching**
>
> 以下也没有考虑事务，比如更新数据库成功，更新缓存失败如何处理？

**更新场景，如何保证缓存和数据库的一致性**

**错误：**

- **缓存采用更新**，不管跟数据库的先后顺序，都会出现**并发时缓存跟数据库的不一致**问题；
  - 线程 A 更新数据库（X = 1）
  - 线程 B 更新数据库（X = 2）
  - 线程 B 更新缓存（X = 2）
  - 线程 A 更新缓存（X = 1）

- **先删缓存，再更新数据库**
  - 两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据。



**思路：**

- **Cache Aside ：先更新数据库，再删缓存**
  - **写-读-写问题**：第一个写导致缓存失效，读操作没有命中缓存，到数据库中取数据；第二个写操作，写完数据库后，让缓存失效**，然后之前的那个读操作再把老的数据放进去**，所以会造成脏数据；
  - 概率极低：发生在读缓存时缓存失效，而且并发着有一个写操作，**读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存**
- **Read/Write Through**：缓存代理数据库的更新操作，对外表现为**原子性操作**（缓存更新和数据库更新）
- **Write behind（Write back**）：同步更新缓存，异步更新数据库
  - 可能会丢失更新



因此，一般采用**先更新数据库，再删缓存**的策略：**事务性保证，如果更新缓存失败**

- **异步重试**（引入消息队列，消息队列跟缓存同时失败概率不大）；
- **缓存过期时间**（一定时间的数据不一致性）；



### 缓存击穿

缓存中没有而数据库中有（一般缓存到期），**访问量大的情况下，同时去读取数据库**

- 根因：1）缓存失效；2）并发访问数据库
- 解决方案：
  - **设置永不过期**；
  - 加锁，分布式锁；（或者每个**实例加锁**，实例数不会很多）



### 缓存雪崩

某个集中的时间，缓存全部失效，查询全部到数据库，压力大

- 根因：集中创建缓存，相同的缓存失效时间

- 自然的雪崩，问题不大，数据库可以抗住压力（因为之前以前集中创建过缓存）

- 解决：创建**不同的缓存失效时间**




### 缓存穿透

**数据中不存在的数据**

- 根因：对于数据库中查询结果不存在的情况，不进行缓存；
- 结果：每次查询，都会在数据库中查；
- 解决：对于**不在数据库中的情况，也进行缓存**，过期时间设置短点；



## 缓存系统



**选型**

- 如果只是本地简单、少量缓存数据使用的，选择`Caffeine`；
- 如果本地缓存数据量较大、内存不足需要使用磁盘缓存的，选择`EhCache`；
- 如果是大型分布式多节点系统，业务对缓存使用较为重度，且各个节点需要依赖并频繁操作同一个缓存，选择`Redis`Caffeine



### 单机[Caffine](https://github.com/ben-manes/caffeine)

> [`W-TinyLFU` 算法](../../code_guide/algs/w_tinylfu.md)



### 分布式Redis

[redis 简介和用法](../../data_system/cache_system/redis.md)



### 混合Ehcache

- 支持**堆内、堆外、磁盘**、集群等多级缓存；
  - 堆内有GC，堆外有序列化/反序列化，磁盘有IO；
- 支持配置**缓存容量**（记录数、字节数）；
- 支持使用磁盘来对缓存内容进行**持久化**保存

限制：

- 多级缓存，按照`堆内缓存 < 堆外缓存 < 磁盘缓存 < 集群缓存`的顺序进行组合；
- 多级缓存中的容量设定必须遵循`堆内缓存 < 堆外缓存 < 磁盘缓存 < 集群缓存`的原则；

- 多级缓存中不允许**磁盘缓存与集群缓存**同时出现；

集群模式：

- 将多实例节点互相连接，当更新时进行节点间同步；
- 支持 RMI 组播，JMS消息，Cache Server，JGroup等方式；



## 缓存库

### [OSChina J2Cache](https://gitee.com/ld/J2Cache)(两级缓存)

> 第一级缓存使用内存(同时支持 Ehcache 2.x、Ehcache 3.x 和 Caffeine)；
>
> 第二级缓存使用 Redis(推荐)/Memcached。

**数据更新**

- 从数据库中读取最新数据，**依次更新 L1 -> L2** ，发送广播清除某个缓存信息
- 接收到广播（手工清除缓存 & 一级缓存自动失效），从 L1 中清除指定的缓存信息

**Region**: 不同的数据会有不同的 TTL 策略：

- 因为Java 本地缓存不可以针对不同的 key 设置不同的 TTL 时间；
- **不同的 region 来存放不同的缓存数据，指定数据量和TTL时间；**



### [Ali J2tCache](https://github.com/oschina/J2Cache)（两级缓存）

> 基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用。
>
> 原生的支持TTL、两级缓存、分布式自动刷新，还提供了Cache接口用于手工缓存操作。 

当前有四个实现，RedisCache、TairCache、CaffeineCache(in memory) 和一个简易的 LinkedHashMapCache(in memory)。



### Spring CacheManager

> 示例: [spring cache](https://gitee.com/oscsc/web-tech/tree/master/cache/springcache)

按照 name 区分 Cache

- 不支持针对每个记录设置不同的过期时间，可以对一组值设置不同的过期时间

- `RedisCacheManager`需要单独引入

#### Redis 客户端

- spring 默认集成 lettuce；

#### 注解

```java
@EnableCaching
// 类上定义使用 Cache
@CacheConfig
// 方法上定义，缓存返回结果，如果缓存存在，则不执行方法（一般用在获取方法）
@Cacheable
// 方法上定义，缓存返回结果，方法总会执行（一般用在新增方法）
@CachePut
// 删除缓存（一般用作更新或删除，保证一致性）
@CacheEvict
```







