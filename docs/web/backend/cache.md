# 缓存

## [OSChina J2Cache](https://gitee.com/ld/J2Cache)(两级缓存)

> 第一级缓存使用内存(同时支持 Ehcache 2.x、Ehcache 3.x 和 Caffeine)；
>
> 第二级缓存使用 Redis(推荐)/Memcached。

**数据更新**

- 从数据库中读取最新数据，**依次更新 L1 -> L2** ，发送广播清除某个缓存信息
- 接收到广播（手工清除缓存 & 一级缓存自动失效），从 L1 中清除指定的缓存信息

**Region**: 不同的数据会有不同的 TTL 策略：

- 因为Java 本地缓存不可以针对不同的 key 设置不同的 TTL 时间；
- **不同的 region 来存放不同的缓存数据，指定数据量和TTL时间；**



## [Ali J2tCache](https://github.com/oschina/J2Cache)（两级缓存）

> 基于Java的缓存系统封装，提供统一的API和注解来简化缓存的使用。
>
> 

原生的支持TTL、两级缓存、分布式自动刷新，还提供了Cache接口用于手工缓存操作。 

当前有四个实现，RedisCache、TairCache、CaffeineCache(in memory)和一个简易的LinkedHashMapCache(in memory)。



JetCache存在问题：

-  二级缓存结构下：local cache的一致性问题



## Spring CacheManager





## 相关问题

### 一致性问题

> 缓存最好设置 TTL，至少最终一致性。
>
> [缓存更新的套路 | 酷 壳 - CoolShell](https://coolshell.cn/articles/17416.html)
>
> 更新缓存的的Design Pattern有四种：**Cache aside, Read through, Write through, Write behind caching**
>
> 以下也没有考虑事务，比如更新数据库成功，更新缓存失败如何处理？

**更新场景，如何保证缓存和数据库的一致性**

**错误：**

- **缓存采用更新**，不管跟数据库的先后顺序，都会出现并发时缓存跟数据库的不一致问题；
  - 线程 A 更新数据库（X = 1）
  - 线程 B 更新数据库（X = 2）
  - 线程 B 更新缓存（X = 2）
  - 线程 A 更新缓存（X = 1）

- **先删缓存，再更新数据库**
  - 两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据。



**思路：**

- **Cache Aside ：先更新数据库，再删缓存**
  - **写-读-写问题**：第一个写导致缓存失效，读操作没有命中缓存，到数据库中取数据；第二个写操作，写完数据库后，让缓存失效**，然后之前的那个读操作再把老的数据放进去**，所以会造成脏数据；
  - 概率极低：发生在读缓存时缓存失效，而且并发着有一个写操作，**读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存**
- **Read/Write Through**：缓存代理数据库的更新操作，对外表现为**原子性操作**（缓存更新和数据库更新）
- **Write behind（Write back**）：同步更新缓存，异步更新数据库
  - 可能会丢失更新



因此，一般采用**先更新数据库，再删缓存**的策略：**事务性保证，如果更新缓存失败**

- **异步重试**（引入消息队列，消息队列跟缓存同时失败概率不大）；
- **缓存过期时间**（一定时间的数据不一致性）；



### 缓存击穿

缓存中没有而数据库中有（一般缓存到期），访问量大的情况下，同时去读取数据库

- 根因：1）缓存失效；2）并发访问数据库
- 解决方案：
  - 设置永不过期；
  - 加锁，分布式锁；（或者每个实例加锁，实例数不会很多）



### 缓存雪崩

某个集中的时间，缓存全部失效，查询全部到数据库，压力大

- 根因：集中创建缓存，相同的缓存失效时间

- 自然的雪崩，问题不大，数据库可以抗住压力（因为之前以前集中创建过缓存）

- 解决：创建**不同的缓存失效时间**




### 缓存穿透

**数据中不存在的数据**

- 根因：对于数据库中查询结果不存在的情况，不进行缓存；
- 结果：每次查询，都会在数据库中查；
- 解决：对于**不在数据库中的情况，也进行缓存**，过期时间设置短点（可能会造成其他什么问题？）；



## 