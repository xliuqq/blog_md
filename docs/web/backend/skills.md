# 技巧

## 缓存

在 读/写 的情况下，如何保证缓存和DB的一致性？

### 一致性

> [缓存更新的套路 | 酷 壳 - CoolShell](https://coolshell.cn/articles/17416.html)
>
> 更新缓存的的Design Pattern有四种：**Cache aside, Read through, Write through, Write behind caching**
>
> 以下也没有考虑事务，比如更新数据库成功，更新缓存失败如何处理？

更新场景，如何保证缓存和数据库的一致性

- Cache Aside ：先删数据库，再删缓存
  - 写-读-写问题：第一个写导致缓存失效，读操作没有命中缓存，到数据库中取数据；第二个写操作，写完数据库后，让缓存失效**，然后之前的那个读操作再把老的数据放进去**，所以会造成脏数据；
  - 概率极低：发生在读缓存时缓存失效，而且并发着有一个写操作，**读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存**
- Read/Write Through：缓存代理数据库的更新操作，对外表现为原子性操作（缓存更新和数据库更新）
- Write beind（write back）：同步更新缓存，异步更新数据库
  - 可能会丢失更新



**错误：先删缓存，再删数据库**

- 两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据。



### 缓存击穿

缓存中没有而数据库中有（一般缓存到期），访问量大的情况下，同时去读取数据库

- 根因：1）缓存失效；2）并发访问数据库
- 解决方案：
  - 设置永不过期；
  - 加锁，分布式锁；

### 缓存雪崩

某个集中的时间，缓存全部失效，查询全部到数据库，压力大

- 根因：集中创建缓存，相同的缓存失效时间

- 自然的雪崩，问题不大，数据库可以抗住压力（因为之前以前集中创建过缓存）

- 解决：创建**不同的缓存失效时间**


### 缓存穿透

**数据中不存在的数据**

- 根因：对于数据库中查询结果不存在的情况，不进行缓存；
- 结果：每次查询，都会在数据库中查；
- 解决：对于**不在数据库中的情况，也进行缓存**，过期时间设置短点（可能会造成其他什么问题？）；





## 清理

### 临时文件的清除（上传后不用）

一般来说：先上传文件，然后在将返回的 ID 作为字段存储到数据库中；

问题：上传完文件后，如何知道该文件是否被系统使用，防止垃圾无限增长？



### 被覆盖文件的删除（上传后被覆盖）

**对于用户的头像，多次上传之后，之前的图片应该被删掉。**



### 正常删除

要求：用户一致性，即用户不能看到部分删除的场景。

如：**删除用户时，用户相关的图片数据应该被删掉。**

- 这是两步操作，分别是数据库操作和图片操作。

|                      | 问题                         | 后果                         | 解决方案                     |
| -------------------- | ---------------------------- | ---------------------------- | ---------------------------- |
| 先删数据库，再删图片 | 数据库删除成功，图片删除失败 | 用户可以登录，但无法看到图片 | 加入事务，数据库回滚         |
| 先删数据库，再删图片 | 图片删除成功，数据库删除失败 | 图片无法清除，存留垃圾       | 图片删除事件，单独GC线程处理 |
