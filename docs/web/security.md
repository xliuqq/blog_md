[toc]

# 安全

## 加密解密

- 对称加密：加密和解密密钥相同，如DES和AES；密钥的安全性很重要；
- 非对称加密：公钥和私钥，只能互相加密、解密；如RSA

### AES(Advanced Encryption Standard)

- 分组加密标准，每个加密块大小为128位，允许的密钥长度为128、192和256位；

- ECB：电子密码本模式：Electronic codebook
  - 每块数据的加密独立，因此加密和解密都可以并行计算，最大的缺点是相同的明文块会被加密成相同的密文块，在某些环境不能提供严格的数据保密性；

- CBC模式：密码分组链接：Cipher-block     chaining
  - 每个待加密的密码块在加密前会先与前一个密码块的密文异或然后再用加密器加密，第一个明文块与一个叫初始化向量的数据块异或；

- CFB模式：密文反馈:Cipher feedback
  - 块密文（Block Cipher）转换为流密文（Stream Cipher），适合对流数据进行加密，解密可以并行计算

- OFB模式（输出反馈：Output feedback）
  - 块加密器生成密钥流（Keystream），然后再将密钥流与明文流异或得到密文流，解密是先用块加密器生成密钥流，再将密钥流与密文流异或得到明文；
  - 加密和解密都不能并行

### RSA算法

使用不同的**加密密钥**与**解密密钥**，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。

加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK。

#### 原理

**根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥**。

步骤：

1. 任意选取两个不同的大素数p和q计算乘积$n=pq$, $\phi(n)=(p-1)(q-1)$；
2. 任意选取一个大整数e，满足$gcd(e,\phi(n)) = 1$，整数e作为加密密钥；
3. 确定解密密钥d，满足$ (de) mod \phi(n) =1$，即$de=k\phi(n)+1,k>=1$，根据$e$和$\phi(n)$很容易计算出d；
4. 公开整数n和e，秘密保存d；
5. 将明文m（m<n是一个整数）加密成密文c，加密算法为$c=E(m)=m^e mod n$
6. 解密密文c，算法为$m=D(c)=c^d mod n$

注：只根据n和e（注意：不是p和q）要计算出d是不可能的

RSA算法本身要求加密内容也就是**明文长度m必须0<m<密钥长度n**:

- 如果小于这个长度就需要进行padding，因为如果没有padding，就无法确定解密后内容的真实长度；
- 如果要对任意长度的数据进行加密，就需要将数据分段后进行逐一加密，并将结果进行拼接。

## 摘要（散列，Hash）算法

- 不同内容的散列值，相同的概率极低；相同内容的散列值一定一样；
- MD5，SHA-1

## 数字签名

- 基于非对称加密，使用私钥进行加密；
- 加密速度慢，使用**摘要算法和非对称算法结合（数字签名）**或**对称加密与非对称加密结合（加密传输文件，对对称密钥加密）**办法；
- 明文+密文，内容被窃取不重要，目的是验证明文的有效正确；

## 数字证书

- 数字证书是由一个权威机构发行的，至少包含一个公开密钥、证书持有人（或单位）的名称以及证书授权中心对这些信息的数字签名的文件；
- pfx证书文件是带公钥和私钥，而cer文件只带公钥；
- jks（Java Key Store），jdk/bin/keytool.exe进行查看、导入、导出、删除；
- key通常指私钥；CSR证书签名请求，简单理解成公钥；CRT，CER，证书，编码可以是（PEM格式可读，DER格式二进制不可读）；
- pem文件一般是文本格式的，可以放证书或者私钥，或者两者都有；pem如果只含私钥的话，一般用.key扩展名，而且可以有密码保护；
- 最顶层的权威安全的叫根证书；

### 自签名的证书

- 使用证书生成工具如OpenSSL，jdk的keytool为自己的https站点生成的证书；
- 双向认证：服务端保存着客户端的证书并信任该证书，客户端保存着服务端的证书并信任该证书，如网上银行、企业应用对接；
- 单项认证：客户端保存服务端的证书并信任该证书；

### HTTTPS

- HTTP + Secure Socket Layer(SSL) 或 Transport Layer Security，在传输层对网络连接进行加密；
- SSL使用证书来创建安全连接；