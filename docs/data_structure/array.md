# 数组

## 堆

堆可以用数组进行实现，堆是个完全二叉树。

## 树状数组

树状数组（**B**inary **I**ndex **T**ree, **BIT**），最简单的树状数组支持两种操作，时间复杂度均为 Olg(n)：

- **单点修改**：更改数组中一个元素的值
- **区间查询**：查询一个区间内所有元素的和

对于普通数组而言，**单点修改**的时间复杂度是O(1)，但**区间求和**的复杂度是O(n)。

### 原理

树状数组的定义：

- 二进制数最右边的一个1，连带着它之后的0为$lowbit(x)$，用$C(i)$维护区间$(A_i-lowbit(A_i), Ai]$，这样查询前n项和时需要合并的区间数是少于$log_2(n)$：

<img src="pics/tree_array.jpg" alt="tree_array" style="zoom: 67%;" />

更新就是一个“**爬树**”的过程。一路往上更新，直到MAXN（树状数组的容量）。

<img src="pics/tree_array_update.jpg" alt="tree_array_update" style="zoom:67%;" />



$lowbit(x)=(x)\&(-x)$

### 代码

见***TreeArray.java***



## 线段数组

用于维护**区间信息**（要求满足结合律）。与树状数组相比，它可以实现 Olg(n) 的**区间修改**，还可以同时支持**多种操作**（加、乘)，更具通用性。

线段树是一棵**平衡二叉树**：

- **母结点代表整个区间的和**，越往下区间越小；
- 线段树的每个**节点**都对应一条**线段（区间）**，但并不保证所有的线段（区间）都是线段树的节点
- 对于线段树中的每一个**非叶子节点[a,b]**，它的左儿子表示的区间为**[a,(a+b)/2]**，右儿子表示的区间为**[(a+b)/2+1,b]**

### 原理

> 参考：https://zhuanlan.zhihu.com/p/106118909

就是**将[1,n]分解成若干特定的子区间（数量不超过4*n）**，然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。

用线段树统计的东西，必须**符合区间加法**，否则，不可能通过分成的子区间来得到[L,R]的统计结果。

符合区间加法的例子：

- 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和

- 最大公因数(GCD)——总GCD = gcd(左区间GCD , 右区间GCD );

- 最大值——总最大值=max(左区间最大值，右区间最大值)

不符合区间加法的例子：

-  众数——只知道左右区间的众数，没法求总区间的众数
-  01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零

![segment_tree.png](pics/segment_tree.png)

“**懒标记**”（或延迟标记）：区间修改

- 朴素的想法是用**递归**的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高；
- 使用懒标记，对于那些正好是线段树节点的区间，我们不继续递归下去，而是打上一个**标记**，将来要用到它的**子区间**的时候，再向下**传递**；
  - 向下延迟修改，但是向上显示的信息是修改以后的信息



标记有**相对标记**和**绝对标记**之分：**非递归线段树**只能维护相对标记。

**相对标记**是将区间的所有数+a之类的操作，标记之间可以共存，跟打标记的顺序无关（跟顺序无关才是重点）。

所以，可以在区间修改的时候不下推标记，留到查询的时候再下推。

**绝对标记**是将区间的所有数变成a之类的操作，打标记的顺序直接影响结果，

所以这种标记在区间修改的时候必须下推旧标记，不然会出错。