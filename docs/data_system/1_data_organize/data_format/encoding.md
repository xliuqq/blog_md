# 常见的编码方式

有符号整数

正数 -> 负数 ：取反后加1 或 减1后取反 

负数 -> 正数 ：减1后取反 或 取反后加1

```properties
# Byte 为例
+3 : 0000011
-3 : 1111101
```



## <a name="zigzag">ZigZag</a>

### 编码

在网络传输和数据存储场景中，需要对数据进行压缩。数据压缩的算法非常多，但**大部分的数据压缩算法的原理是通过某种编码方式不存储数据中的0比特位，因此0比特位越多，数据压缩的效果越好**。ZigZag编码就是一种增加0比例位的编码方式。

```properties
# 以byte（8位）为例
ZigZag(n) = n>>7 ^ n<<1
```

ZigZag的编码后的数据以无符号表示，其效果：

**正数**：等价于乘 2（n<<1），无符号值表示为 $|n| << 2$

**负数**：等于 ~(n << 1)，无符号值表示为 $|n| << 2 + 1$

-11的处理过程如下：

1. `11110101 >> 7 = 11111111`
2. `11110101 << 1 = 11101010`
3. `11111111^11101010 = 00010101`

正数经过处理后，前导0和后置0的个数不变。但是负数经过处理后，增加了三个前导0，可以用于压缩。

### 解码

```
~ZigZag(n) = (n >>> 1) ^ ~ (n & 1)
```

-11的ZigZag编码`00010101`的解码过程：

1. n>>>1：`00001010`
3. ~(n&1): `11111110`
4. `1111110 ^ 0000101=11110101`



## RLE(行程编码)

针对连续重复的数据，记录重复次数和对应的值。

示例

```
aaaaabbbcdeeeeeeef...
=> 5a3b1c1d7e1f...
```



## ULEB128

Unsigned Little Endian Base 128

每个字节 = 1bit symbol+ 7bit data

- uleb128编码的整形值，是以字节中最高位是否为0（symbol位）来表示字节流有没有结束的。
- uleb128编码的整形值，其占用的字节数是不确定的，长度有可能在1到5个字节之间变化；

第一个字节代表的是整形值的最低7比特位的值，第二个字节代表整型值的次低7比特位的值，以此类推，最后一个字节（最高位为0）代表整形值的最高7比特位的值。



## 差分/增量编码（Differential/Delta Coding)

保留连续元素之间的差异以及初始值，差异或增量是非负整数，通常比原始整数小得多， 因此它们可以被更有效地压缩。

- 第一次计算的负数增量，可以通过最小负数，将其转换为正数，见[Parquet的Delta Coding](./parquet/encoding#DELE)；
- 随机访问位于给定索引处的整数可能需要对几个增量求和，将大型数组划分为较小的数组来缓解此问题。

> SIMD，单指令多数据； SSE2，单指令多数据流技术扩展 2； SSSE3，单指令多数据流技术扩展 3。 

使用基于单指令多数据（SIMD）操作的专用方案压缩这些整数数组可能更可取；

使用SIMD指令的向量化前缀总和可以快两倍；

