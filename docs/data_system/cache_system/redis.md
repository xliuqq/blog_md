# Redis

- 支持多种数据类型，包括 Json（支持索引）和Graph；

## 功能

### 客户端缓存（Redis 6）

支持客户端（APP端）缓存，无需手动的Pub/Sub，保持客户端和Redis的数据一致性；
- **默认模式**：服务端会记录某个客户端具体访问过哪一些`key`，当这些`key`对应的值发生变化时，会**发送失效消息**给这些客户端。**服务端内存消耗大**；
- **广播模式**：客户端需要订阅`key`的**特定前缀**，每当符合这个前缀的`key`对应的值发生改变时，客户端都会收到通知消息。
### 发布订阅（Pub/Sub）



### 持久化
- **RDB**：根据指定的规则“**定时**”将内存中的数据存储在硬盘上，默认；
- **AOF**：每次执行命令后将命令本身记录下来。



## 高可用方案

### 主从

Redis提供了复制(replication)功能，当一台redis数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis机器。

- 主节点挂掉后，从节点需要**手动操作**变成主节点，同时其它从节点需要变更配置；

  ```bash
  # 从节点启动
  ./redis-server --slaveof 192.168.1.10 6379
   
  # 在 ./redis-cli 上执行下面命令，变成 master
  slaveof no one
  ```

   

### 哨兵

master宕机，哨兵会**自动选举**master并将其他的slave指向新的master

- 哨兵是一个独立的进程，奇数个哨兵进行决策选举；
- 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器;
- 当多个哨兵监测到master宕机，选举某个slave变成master，然后通过*发布订阅模式*通过其他的从服务器，修改配置文件，让它们切换master;



### 集群

### Redis原生集群

> **Redis 3.0**：没有使用一致性Hash，而是**使用哈希槽（hash slot）**
>
> - redis集群使用gossip协议来广播自己的状态以及接受其他实例的信息

每个哈希槽都有一个唯一的编号，范围从0到16383。

- 当一个键值对需要存储时，Redis使用CRC16算法计算键的哈希值，并将其映射到一个哈希槽中；
- Redis 将该键值对存储在负责该哈希槽的节点上
- 当一个节点离线或失败时，它负责的哈希槽会被重新分配给其他节点

当客户端发送一个命令时，Redis节点会首先计算该命令所涉及的键值的哈希槽，并将该命令**路由**到负责该哈希槽的Redis节点上。

- 如果该节点不是客户端所连接的节点，则Redis节点会返回一个`MOVED`错误，告诉客户端应该将该命令重定向到负责该哈希槽的节点上。客户端会根据`MOVED`**错误中返回的地址信息来重新连接到正确的节点**，并重新发送该命令。
- 客户端在客户端在此期间向离线或故障的节点发送命令时向其发送命令，会导致命令失败或者超时，因此需要关注**故障转移和自动重试**；



### Proxy集群Codis

> [一致性Hash](../../distributed_consensus/distributed_hash.md#一致性Hash算法)

Proxy：将客户端请求路由到正确的后端Redis实例，将键映射到后端Redis实例

- 当一个客户端请求到达Codis集群时，它会首先被路由到一个Proxy实例；
- Proxy会根据哈希槽分布图将请求路由到正确的后端Redis实例，并将响应返回给客户端；
- 如果一个后端Redis实例发生故障或离线，Proxy会自动将该实例从哈希槽分布图中删除，并将其负责的哈希槽分配给其他Redis实例。



## Client

### [Jedis](https://github.com/redis/jedis)

- 多线程环境下是非线程安全，使用连接池；
- 同步阻塞 IO，不支持异步；

### [Lettuce](https://github.com/lettuce-io/lettuce-core)

- 基于 `Netty`框架(NIO)的事件驱动的通信，支持同步和异步调用
- 多线程安全，多个线程对应底层一个物理连接；
- 可以配置线程池，增加连接实例；
- 支持异步IO；
